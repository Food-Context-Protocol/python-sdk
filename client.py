# This file was auto-generated by Fern from our API Definition.

import typing
import httpx
from .core.client_wrapper import SyncClientWrapper
from .meals.client import MealsClient
from .search.client import SearchClient
from .safety.client import SafetyClient
from .profile.client import ProfileClient
from .publishing.client import PublishingClient
from .analyze.client import AnalyzeClient
from .analytics.client import AnalyticsClient
from .agents.client import AgentsClient
from .inventory.client import InventoryClient
from .knowledge.client import KnowledgeClient
from .discovery.client import DiscoveryClient
from .recipes.client import RecipesClient
from .social.client import SocialClient
from .connectors.client import ConnectorsClient
from .external.client import ExternalClient
from .scheduler.client import SchedulerClient
from .parser.client import ParserClient
from .misc.client import MiscClient
from .research.client import ResearchClient
from .video.client import VideoClient
from .voice.client import VoiceClient
from .health.client import HealthClient
from .core.request_options import RequestOptions
from .core.pydantic_utilities import parse_obj_as
from json.decoder import JSONDecodeError
from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper
from .meals.client import AsyncMealsClient
from .search.client import AsyncSearchClient
from .safety.client import AsyncSafetyClient
from .profile.client import AsyncProfileClient
from .publishing.client import AsyncPublishingClient
from .analyze.client import AsyncAnalyzeClient
from .analytics.client import AsyncAnalyticsClient
from .agents.client import AsyncAgentsClient
from .inventory.client import AsyncInventoryClient
from .knowledge.client import AsyncKnowledgeClient
from .discovery.client import AsyncDiscoveryClient
from .recipes.client import AsyncRecipesClient
from .social.client import AsyncSocialClient
from .connectors.client import AsyncConnectorsClient
from .external.client import AsyncExternalClient
from .scheduler.client import AsyncSchedulerClient
from .parser.client import AsyncParserClient
from .misc.client import AsyncMiscClient
from .research.client import AsyncResearchClient
from .video.client import AsyncVideoClient
from .voice.client import AsyncVoiceClient
from .health.client import AsyncHealthClient


class FoodContextProtocolApi:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : str
        The base url to use for requests from the client.

    authorization : typing.Optional[str]
    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 60 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.Client]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from fcp import FoodContextProtocolApi

    client = FoodContextProtocolApi(
        authorization="YOUR_AUTHORIZATION",
        base_url="https://yourhost.com/path/to/api",
    )
    """

    def __init__(
        self,
        *,
        base_url: str,
        authorization: typing.Optional[str] = None,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 60 if httpx_client is None else None
        )
        self._client_wrapper = SyncClientWrapper(
            base_url=base_url,
            authorization=authorization,
            httpx_client=httpx_client
            if httpx_client is not None
            else httpx.Client(
                timeout=_defaulted_timeout, follow_redirects=follow_redirects
            )
            if follow_redirects is not None
            else httpx.Client(timeout=_defaulted_timeout),
            timeout=_defaulted_timeout,
        )
        self.meals = MealsClient(client_wrapper=self._client_wrapper)
        self.search = SearchClient(client_wrapper=self._client_wrapper)
        self.safety = SafetyClient(client_wrapper=self._client_wrapper)
        self.profile = ProfileClient(client_wrapper=self._client_wrapper)
        self.publishing = PublishingClient(client_wrapper=self._client_wrapper)
        self.analyze = AnalyzeClient(client_wrapper=self._client_wrapper)
        self.analytics = AnalyticsClient(client_wrapper=self._client_wrapper)
        self.agents = AgentsClient(client_wrapper=self._client_wrapper)
        self.inventory = InventoryClient(client_wrapper=self._client_wrapper)
        self.knowledge = KnowledgeClient(client_wrapper=self._client_wrapper)
        self.discovery = DiscoveryClient(client_wrapper=self._client_wrapper)
        self.recipes = RecipesClient(client_wrapper=self._client_wrapper)
        self.social = SocialClient(client_wrapper=self._client_wrapper)
        self.connectors = ConnectorsClient(client_wrapper=self._client_wrapper)
        self.external = ExternalClient(client_wrapper=self._client_wrapper)
        self.scheduler = SchedulerClient(client_wrapper=self._client_wrapper)
        self.parser = ParserClient(client_wrapper=self._client_wrapper)
        self.misc = MiscClient(client_wrapper=self._client_wrapper)
        self.research = ResearchClient(client_wrapper=self._client_wrapper)
        self.video = VideoClient(client_wrapper=self._client_wrapper)
        self.voice = VoiceClient(client_wrapper=self._client_wrapper)
        self.health = HealthClient(client_wrapper=self._client_wrapper)

    def root_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Optional[typing.Any]:
        """
        Health check.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.root_get()
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncFoodContextProtocolApi:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : str
        The base url to use for requests from the client.

    authorization : typing.Optional[str]
    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 60 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.AsyncClient]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from fcp import AsyncFoodContextProtocolApi

    client = AsyncFoodContextProtocolApi(
        authorization="YOUR_AUTHORIZATION",
        base_url="https://yourhost.com/path/to/api",
    )
    """

    def __init__(
        self,
        *,
        base_url: str,
        authorization: typing.Optional[str] = None,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 60 if httpx_client is None else None
        )
        self._client_wrapper = AsyncClientWrapper(
            base_url=base_url,
            authorization=authorization,
            httpx_client=httpx_client
            if httpx_client is not None
            else httpx.AsyncClient(
                timeout=_defaulted_timeout, follow_redirects=follow_redirects
            )
            if follow_redirects is not None
            else httpx.AsyncClient(timeout=_defaulted_timeout),
            timeout=_defaulted_timeout,
        )
        self.meals = AsyncMealsClient(client_wrapper=self._client_wrapper)
        self.search = AsyncSearchClient(client_wrapper=self._client_wrapper)
        self.safety = AsyncSafetyClient(client_wrapper=self._client_wrapper)
        self.profile = AsyncProfileClient(client_wrapper=self._client_wrapper)
        self.publishing = AsyncPublishingClient(client_wrapper=self._client_wrapper)
        self.analyze = AsyncAnalyzeClient(client_wrapper=self._client_wrapper)
        self.analytics = AsyncAnalyticsClient(client_wrapper=self._client_wrapper)
        self.agents = AsyncAgentsClient(client_wrapper=self._client_wrapper)
        self.inventory = AsyncInventoryClient(client_wrapper=self._client_wrapper)
        self.knowledge = AsyncKnowledgeClient(client_wrapper=self._client_wrapper)
        self.discovery = AsyncDiscoveryClient(client_wrapper=self._client_wrapper)
        self.recipes = AsyncRecipesClient(client_wrapper=self._client_wrapper)
        self.social = AsyncSocialClient(client_wrapper=self._client_wrapper)
        self.connectors = AsyncConnectorsClient(client_wrapper=self._client_wrapper)
        self.external = AsyncExternalClient(client_wrapper=self._client_wrapper)
        self.scheduler = AsyncSchedulerClient(client_wrapper=self._client_wrapper)
        self.parser = AsyncParserClient(client_wrapper=self._client_wrapper)
        self.misc = AsyncMiscClient(client_wrapper=self._client_wrapper)
        self.research = AsyncResearchClient(client_wrapper=self._client_wrapper)
        self.video = AsyncVideoClient(client_wrapper=self._client_wrapper)
        self.voice = AsyncVoiceClient(client_wrapper=self._client_wrapper)
        self.health = AsyncHealthClient(client_wrapper=self._client_wrapper)

    async def root_get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Optional[typing.Any]:
        """
        Health check.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.root_get()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
