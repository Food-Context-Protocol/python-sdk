# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..core.request_options import RequestOptions
from ..core.pydantic_utilities import parse_obj_as
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.http_validation_error import HttpValidationError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..core.jsonable_encoder import jsonable_encoder
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AgentsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def post_delegate_to_agent(
        self,
        *,
        agent_name: str,
        objective: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Handoff a complex food-related task to a specialized agent.

        Parameters
        ----------
        agent_name : str

        objective : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.post_delegate_to_agent(
            agent_name="agent_name",
            objective="objective",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/delegate",
            method="POST",
            json={
                "agent_name": agent_name,
                "objective": objective,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def run_food_discovery(
        self,
        *,
        location: typing.Optional[str] = OMIT,
        discovery_type: typing.Optional[str] = OMIT,
        count: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Run autonomous food discovery agent.

        Combines:
        - Google Search grounding for real-time data
        - Extended thinking for preference matching
        - Function calling for structured recommendations

        Parameters
        ----------
        location : typing.Optional[str]

        discovery_type : typing.Optional[str]

        count : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.run_food_discovery()
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/discover",
            method="POST",
            json={
                "location": location,
                "discovery_type": discovery_type,
                "count": count,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def discover_restaurants(
        self,
        *,
        location: str,
        occasion: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Discover new restaurants matching user preferences.

        Parameters
        ----------
        location : str

        occasion : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.discover_restaurants(
            location="location",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/discover/restaurants",
            method="POST",
            json={
                "location": location,
                "occasion": occasion,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def discover_recipes(
        self,
        *,
        available_ingredients: typing.Optional[typing.Sequence[str]] = OMIT,
        dietary_restrictions: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Discover new recipes based on preferences and available ingredients.

        Parameters
        ----------
        available_ingredients : typing.Optional[typing.Sequence[str]]

        dietary_restrictions : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.discover_recipes()
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/discover/recipes",
            method="POST",
            json={
                "available_ingredients": available_ingredients,
                "dietary_restrictions": dietary_restrictions,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_daily_insight(
        self,
        *,
        location: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Get today's personalized food insight.

        Uses grounding for timely, relevant content:
        - What's in season
        - Food holidays
        - Weather-appropriate suggestions

        Parameters
        ----------
        location : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.get_daily_insight()
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/daily-insight",
            method="GET",
            params={
                "location": location,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_streak_celebration(
        self,
        streak_days: int,
        *,
        user_name: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Generate a celebration message for a logging streak.

        Parameters
        ----------
        streak_days : int

        user_name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.get_streak_celebration(
            streak_days=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/streak/{jsonable_encoder(streak_days)}",
            method="GET",
            params={
                "user_name": user_name,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_food_tip(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Get today's food tip based on user preferences.

        Uses grounding for fresh, relevant tips.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.get_food_tip()
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/food-tip",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_seasonal_reminder(
        self, *, location: str, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Get seasonal food recommendations for a location.

        Parameters
        ----------
        location : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.get_seasonal_reminder(
            location="location",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/seasonal-reminder",
            method="GET",
            params={
                "location": location,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def process_media_batch(
        self,
        *,
        image_urls: typing.Sequence[str],
        auto_log: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Process a batch of photos to detect and analyze food.

        Uses:
        - Multimodal analysis for food detection
        - Function calling for structured extraction

        Parameters
        ----------
        image_urls : typing.Sequence[str]

        auto_log : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.process_media_batch(
            image_urls=["image_urls"],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/process-media",
            method="POST",
            json={
                "image_urls": image_urls,
                "auto_log": auto_log,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def filter_food_images(
        self,
        *,
        image_urls: typing.Sequence[str],
        confidence_threshold: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Filter images to identify which contain food.

        Faster than full analysis - only checks food presence.

        Parameters
        ----------
        image_urls : typing.Sequence[str]

        confidence_threshold : typing.Optional[float]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.filter_food_images(
            image_urls=["image_urls"],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/filter-food-images",
            method="POST",
            json={
                "image_urls": image_urls,
                "confidence_threshold": confidence_threshold,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate_blog_content(
        self,
        *,
        user_name: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Generate a shareable weekly food digest.

        Uses extended thinking for creative content generation.

        Parameters
        ----------
        user_name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.generate_blog_content()
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/generate-blog",
            method="POST",
            params={
                "user_name": user_name,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_social_post(
        self,
        *,
        log_id: str,
        platform: typing.Optional[str] = OMIT,
        style: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Generate a social media post.

        Parameters
        ----------
        log_id : str

        platform : typing.Optional[str]

        style : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.create_social_post(
            log_id="log_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/social-post",
            method="POST",
            json={
                "log_id": log_id,
                "platform": platform,
                "style": style,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate_food_story(
        self,
        *,
        log_ids: typing.Sequence[str],
        theme: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Generate a narrative food story from multiple meals.

        Parameters
        ----------
        log_ids : typing.Sequence[str]

        theme : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.generate_food_story(
            log_ids=["log_ids"],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/food-story",
            method="POST",
            json={
                "log_ids": log_ids,
                "theme": theme,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate_monthly_review(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Generate a comprehensive monthly food review.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.generate_monthly_review()
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/monthly-review",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate_recipe_card(
        self,
        *,
        log_id: str,
        include_instructions: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Generate a shareable recipe card from a logged meal.

        Parameters
        ----------
        log_id : str

        include_instructions : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from fcp import FoodContextProtocolApi

        client = FoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )
        client.agents.generate_recipe_card(
            log_id="log_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/recipe-card",
            method="POST",
            json={
                "log_id": log_id,
                "include_instructions": include_instructions,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAgentsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def post_delegate_to_agent(
        self,
        *,
        agent_name: str,
        objective: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Handoff a complex food-related task to a specialized agent.

        Parameters
        ----------
        agent_name : str

        objective : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.post_delegate_to_agent(
                agent_name="agent_name",
                objective="objective",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/delegate",
            method="POST",
            json={
                "agent_name": agent_name,
                "objective": objective,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def run_food_discovery(
        self,
        *,
        location: typing.Optional[str] = OMIT,
        discovery_type: typing.Optional[str] = OMIT,
        count: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Run autonomous food discovery agent.

        Combines:
        - Google Search grounding for real-time data
        - Extended thinking for preference matching
        - Function calling for structured recommendations

        Parameters
        ----------
        location : typing.Optional[str]

        discovery_type : typing.Optional[str]

        count : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.run_food_discovery()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/discover",
            method="POST",
            json={
                "location": location,
                "discovery_type": discovery_type,
                "count": count,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def discover_restaurants(
        self,
        *,
        location: str,
        occasion: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Discover new restaurants matching user preferences.

        Parameters
        ----------
        location : str

        occasion : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.discover_restaurants(
                location="location",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/discover/restaurants",
            method="POST",
            json={
                "location": location,
                "occasion": occasion,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def discover_recipes(
        self,
        *,
        available_ingredients: typing.Optional[typing.Sequence[str]] = OMIT,
        dietary_restrictions: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Discover new recipes based on preferences and available ingredients.

        Parameters
        ----------
        available_ingredients : typing.Optional[typing.Sequence[str]]

        dietary_restrictions : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.discover_recipes()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/discover/recipes",
            method="POST",
            json={
                "available_ingredients": available_ingredients,
                "dietary_restrictions": dietary_restrictions,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_daily_insight(
        self,
        *,
        location: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Get today's personalized food insight.

        Uses grounding for timely, relevant content:
        - What's in season
        - Food holidays
        - Weather-appropriate suggestions

        Parameters
        ----------
        location : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.get_daily_insight()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/daily-insight",
            method="GET",
            params={
                "location": location,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_streak_celebration(
        self,
        streak_days: int,
        *,
        user_name: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Generate a celebration message for a logging streak.

        Parameters
        ----------
        streak_days : int

        user_name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.get_streak_celebration(
                streak_days=1,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/streak/{jsonable_encoder(streak_days)}",
            method="GET",
            params={
                "user_name": user_name,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_food_tip(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Get today's food tip based on user preferences.

        Uses grounding for fresh, relevant tips.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.get_food_tip()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/food-tip",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_seasonal_reminder(
        self, *, location: str, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Get seasonal food recommendations for a location.

        Parameters
        ----------
        location : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.get_seasonal_reminder(
                location="location",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/seasonal-reminder",
            method="GET",
            params={
                "location": location,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def process_media_batch(
        self,
        *,
        image_urls: typing.Sequence[str],
        auto_log: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Process a batch of photos to detect and analyze food.

        Uses:
        - Multimodal analysis for food detection
        - Function calling for structured extraction

        Parameters
        ----------
        image_urls : typing.Sequence[str]

        auto_log : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.process_media_batch(
                image_urls=["image_urls"],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/process-media",
            method="POST",
            json={
                "image_urls": image_urls,
                "auto_log": auto_log,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def filter_food_images(
        self,
        *,
        image_urls: typing.Sequence[str],
        confidence_threshold: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Filter images to identify which contain food.

        Faster than full analysis - only checks food presence.

        Parameters
        ----------
        image_urls : typing.Sequence[str]

        confidence_threshold : typing.Optional[float]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.filter_food_images(
                image_urls=["image_urls"],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/filter-food-images",
            method="POST",
            json={
                "image_urls": image_urls,
                "confidence_threshold": confidence_threshold,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate_blog_content(
        self,
        *,
        user_name: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Generate a shareable weekly food digest.

        Uses extended thinking for creative content generation.

        Parameters
        ----------
        user_name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.generate_blog_content()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/generate-blog",
            method="POST",
            params={
                "user_name": user_name,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_social_post(
        self,
        *,
        log_id: str,
        platform: typing.Optional[str] = OMIT,
        style: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Generate a social media post.

        Parameters
        ----------
        log_id : str

        platform : typing.Optional[str]

        style : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.create_social_post(
                log_id="log_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/social-post",
            method="POST",
            json={
                "log_id": log_id,
                "platform": platform,
                "style": style,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate_food_story(
        self,
        *,
        log_ids: typing.Sequence[str],
        theme: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Generate a narrative food story from multiple meals.

        Parameters
        ----------
        log_ids : typing.Sequence[str]

        theme : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.generate_food_story(
                log_ids=["log_ids"],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/food-story",
            method="POST",
            json={
                "log_ids": log_ids,
                "theme": theme,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate_monthly_review(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Generate a comprehensive monthly food review.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.generate_monthly_review()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/monthly-review",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate_recipe_card(
        self,
        *,
        log_id: str,
        include_instructions: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Generate a shareable recipe card from a logged meal.

        Parameters
        ----------
        log_id : str

        include_instructions : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from fcp import AsyncFoodContextProtocolApi

        client = AsyncFoodContextProtocolApi(
            authorization="YOUR_AUTHORIZATION",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.agents.generate_recipe_card(
                log_id="log_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/recipe-card",
            method="POST",
            json={
                "log_id": log_id,
                "include_instructions": include_instructions,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
